// Generated by gencpp from file campusrover_msgs/CANbus.msg
// DO NOT EDIT!


#ifndef CAMPUSROVER_MSGS_MESSAGE_CANBUS_H
#define CAMPUSROVER_MSGS_MESSAGE_CANBUS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace campusrover_msgs
{
template <class ContainerAllocator>
struct CANbus_
{
  typedef CANbus_<ContainerAllocator> Type;

  CANbus_()
    : id(0)
    , group(0)
    , fun_code(0)
    , reg1(0)
    , value1(0)
    , reg2(0)
    , value2(0)  {
    }
  CANbus_(const ContainerAllocator& _alloc)
    : id(0)
    , group(0)
    , fun_code(0)
    , reg1(0)
    , value1(0)
    , reg2(0)
    , value2(0)  {
  (void)_alloc;
    }



   typedef uint16_t _id_type;
  _id_type id;

   typedef uint16_t _group_type;
  _group_type group;

   typedef uint16_t _fun_code_type;
  _fun_code_type fun_code;

   typedef uint16_t _reg1_type;
  _reg1_type reg1;

   typedef uint16_t _value1_type;
  _value1_type value1;

   typedef uint16_t _reg2_type;
  _reg2_type reg2;

   typedef uint16_t _value2_type;
  _value2_type value2;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(id_container1)
  #undef id_container1
#endif
#if defined(_WIN32) && defined(id_container2)
  #undef id_container2
#endif
#if defined(_WIN32) && defined(id_container3)
  #undef id_container3
#endif
#if defined(_WIN32) && defined(id_container4)
  #undef id_container4
#endif
#if defined(_WIN32) && defined(id_twoside)
  #undef id_twoside
#endif
#if defined(_WIN32) && defined(group_zero)
  #undef group_zero
#endif
#if defined(_WIN32) && defined(group_container)
  #undef group_container
#endif
#if defined(_WIN32) && defined(sending_single)
  #undef sending_single
#endif
#if defined(_WIN32) && defined(sending_group)
  #undef sending_group
#endif
#if defined(_WIN32) && defined(reg_container)
  #undef reg_container
#endif
#if defined(_WIN32) && defined(value_opendoor)
  #undef value_opendoor
#endif
#if defined(_WIN32) && defined(value_closedoor)
  #undef value_closedoor
#endif
#if defined(_WIN32) && defined(reg_containerled)
  #undef reg_containerled
#endif
#if defined(_WIN32) && defined(reg_leftsideled)
  #undef reg_leftsideled
#endif
#if defined(_WIN32) && defined(reg_rightsideled)
  #undef reg_rightsideled
#endif
#if defined(_WIN32) && defined(reg_twosideled)
  #undef reg_twosideled
#endif
#if defined(_WIN32) && defined(value_dark)
  #undef value_dark
#endif
#if defined(_WIN32) && defined(value_light_50)
  #undef value_light_50
#endif
#if defined(_WIN32) && defined(value_light_100)
  #undef value_light_100
#endif
#if defined(_WIN32) && defined(value_breathe)
  #undef value_breathe
#endif
#if defined(_WIN32) && defined(value_blink)
  #undef value_blink
#endif
#if defined(_WIN32) && defined(value_water1)
  #undef value_water1
#endif
#if defined(_WIN32) && defined(value_water2)
  #undef value_water2
#endif
#if defined(_WIN32) && defined(value_water3)
  #undef value_water3
#endif
#if defined(_WIN32) && defined(value_water4)
  #undef value_water4
#endif
#if defined(_WIN32) && defined(value_talking)
  #undef value_talking
#endif
#if defined(_WIN32) && defined(value_nocolor)
  #undef value_nocolor
#endif
#if defined(_WIN32) && defined(value_white)
  #undef value_white
#endif
#if defined(_WIN32) && defined(value_red)
  #undef value_red
#endif
#if defined(_WIN32) && defined(value_green)
  #undef value_green
#endif
#if defined(_WIN32) && defined(value_blue)
  #undef value_blue
#endif
#if defined(_WIN32) && defined(value_purple)
  #undef value_purple
#endif
#if defined(_WIN32) && defined(value_yellow)
  #undef value_yellow
#endif
#if defined(_WIN32) && defined(value_sky)
  #undef value_sky
#endif

  enum {
    id_container1 = 1u,
    id_container2 = 2u,
    id_container3 = 3u,
    id_container4 = 4u,
    id_twoside = 5u,
    group_zero = 0u,
    group_container = 1u,
    sending_single = 26u,
    sending_group = 138u,
    reg_container = 2u,
    value_opendoor = 1u,
    value_closedoor = 0u,
    reg_containerled = 3u,
    reg_leftsideled = 4u,
    reg_rightsideled = 5u,
    reg_twosideled = 6u,
    value_dark = 0u,
    value_light_50 = 1u,
    value_light_100 = 2u,
    value_breathe = 3u,
    value_blink = 4u,
    value_water1 = 5u,
    value_water2 = 6u,
    value_water3 = 7u,
    value_water4 = 8u,
    value_talking = 9u,
    value_nocolor = 0u,
    value_white = 1u,
    value_red = 2u,
    value_green = 3u,
    value_blue = 4u,
    value_purple = 5u,
    value_yellow = 6u,
    value_sky = 7u,
  };


  typedef boost::shared_ptr< ::campusrover_msgs::CANbus_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::campusrover_msgs::CANbus_<ContainerAllocator> const> ConstPtr;

}; // struct CANbus_

typedef ::campusrover_msgs::CANbus_<std::allocator<void> > CANbus;

typedef boost::shared_ptr< ::campusrover_msgs::CANbus > CANbusPtr;
typedef boost::shared_ptr< ::campusrover_msgs::CANbus const> CANbusConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::campusrover_msgs::CANbus_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::campusrover_msgs::CANbus_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::campusrover_msgs::CANbus_<ContainerAllocator1> & lhs, const ::campusrover_msgs::CANbus_<ContainerAllocator2> & rhs)
{
  return lhs.id == rhs.id &&
    lhs.group == rhs.group &&
    lhs.fun_code == rhs.fun_code &&
    lhs.reg1 == rhs.reg1 &&
    lhs.value1 == rhs.value1 &&
    lhs.reg2 == rhs.reg2 &&
    lhs.value2 == rhs.value2;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::campusrover_msgs::CANbus_<ContainerAllocator1> & lhs, const ::campusrover_msgs::CANbus_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace campusrover_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::campusrover_msgs::CANbus_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::campusrover_msgs::CANbus_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::campusrover_msgs::CANbus_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::campusrover_msgs::CANbus_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::campusrover_msgs::CANbus_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::campusrover_msgs::CANbus_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::campusrover_msgs::CANbus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "2a6881bd895ce03d25c554a5c460b8df";
  }

  static const char* value(const ::campusrover_msgs::CANbus_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x2a6881bd895ce03dULL;
  static const uint64_t static_value2 = 0x25c554a5c460b8dfULL;
};

template<class ContainerAllocator>
struct DataType< ::campusrover_msgs::CANbus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "campusrover_msgs/CANbus";
  }

  static const char* value(const ::campusrover_msgs::CANbus_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::campusrover_msgs::CANbus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "uint16 id\n"
"uint16 id_container1 = 1\n"
"uint16 id_container2 = 2\n"
"uint16 id_container3 = 3\n"
"uint16 id_container4 = 4\n"
"uint16 id_twoside = 5\n"
"\n"
"uint16 group\n"
"uint16 group_zero = 0\n"
"uint16 group_container = 1\n"
"\n"
"uint16 fun_code\n"
"uint16 sending_single = 26 #0x1A\n"
"uint16 sending_group = 138 #0x8A\n"
"\n"
"uint16 reg1\n"
"uint16 value1\n"
"uint16 reg2\n"
"uint16 value2\n"
"\n"
"uint16 reg_container = 2\n"
"uint16 value_opendoor = 1\n"
"uint16 value_closedoor = 0\n"
"\n"
"uint16 reg_containerled = 3\n"
"uint16 reg_leftsideled = 4\n"
"uint16 reg_rightsideled = 5\n"
"uint16 reg_twosideled = 6\n"
"uint16 value_dark = 0\n"
"uint16 value_light_50 = 1\n"
"uint16 value_light_100 = 2\n"
"uint16 value_breathe = 3\n"
"uint16 value_blink = 4\n"
"\n"
"uint16 value_water1 = 5\n"
"uint16 value_water2 = 6\n"
"uint16 value_water3 = 7\n"
"uint16 value_water4 = 8\n"
"uint16 value_talking = 9\n"
"\n"
"uint16 value_nocolor = 0\n"
"uint16 value_white = 1\n"
"uint16 value_red = 2\n"
"uint16 value_green = 3\n"
"uint16 value_blue = 4\n"
"uint16 value_purple = 5\n"
"uint16 value_yellow = 6\n"
"uint16 value_sky = 7\n"
;
  }

  static const char* value(const ::campusrover_msgs::CANbus_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::campusrover_msgs::CANbus_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.id);
      stream.next(m.group);
      stream.next(m.fun_code);
      stream.next(m.reg1);
      stream.next(m.value1);
      stream.next(m.reg2);
      stream.next(m.value2);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct CANbus_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::campusrover_msgs::CANbus_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::campusrover_msgs::CANbus_<ContainerAllocator>& v)
  {
    s << indent << "id: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.id);
    s << indent << "group: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.group);
    s << indent << "fun_code: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.fun_code);
    s << indent << "reg1: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.reg1);
    s << indent << "value1: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.value1);
    s << indent << "reg2: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.reg2);
    s << indent << "value2: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.value2);
  }
};

} // namespace message_operations
} // namespace ros

#endif // CAMPUSROVER_MSGS_MESSAGE_CANBUS_H
